import jsPDF from "jspdf";
import { autoTable } from "jspdf-autotable";

const COLORS = {
  primary: [37, 99, 235] as [number, number, number],
  primaryLight: [239, 246, 255] as [number, number, number],
  success: [22, 163, 74] as [number, number, number],
  successBg: [240, 253, 244] as [number, number, number],
  danger: [220, 38, 38] as [number, number, number],
  dangerBg: [254, 242, 242] as [number, number, number],
  warning: [234, 179, 8] as [number, number, number],
  warningBg: [254, 252, 232] as [number, number, number],
  dark: [30, 41, 59] as [number, number, number],
  muted: [100, 116, 139] as [number, number, number],
  border: [226, 232, 240] as [number, number, number],
  white: [255, 255, 255] as [number, number, number],
  bg: [248, 250, 252] as [number, number, number],
  accent: [59, 130, 246] as [number, number, number],
  teal: [20, 184, 166] as [number, number, number],
  tealBg: [240, 253, 250] as [number, number, number],
  purple: [139, 92, 246] as [number, number, number],
  purpleBg: [245, 243, 255] as [number, number, number],
  orange: [249, 115, 22] as [number, number, number],
  orangeBg: [255, 247, 237] as [number, number, number],
  rose: [244, 63, 94] as [number, number, number],
  roseBg: [255, 241, 242] as [number, number, number],
};

interface MedicalHistoryForPdf {
  birth_history: Record<string, any>;
  childhood_illnesses: Record<string, any>;
  medical_conditions: Record<string, any>;
  family_history: Record<string, any>;
  gender_health: Record<string, any>;
  surgeries: Record<string, any>;
  allergies: Record<string, any>;
  body_systems: Record<string, any>;
  lifestyle: Record<string, any>;
  is_complete: boolean;
}

const STEPS = [
  { key: "birth_history", label: "Birth History", icon: "ðŸ¼", color: COLORS.primary, bgColor: COLORS.primaryLight },
  { key: "childhood_illnesses", label: "Childhood Illnesses", icon: "ðŸ§’", color: COLORS.teal, bgColor: COLORS.tealBg },
  { key: "medical_conditions", label: "Medical Conditions", icon: "ðŸ“‹", color: COLORS.danger, bgColor: COLORS.dangerBg },
  { key: "family_history", label: "Family History", icon: "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦", color: COLORS.purple, bgColor: COLORS.purpleBg },
  { key: "gender_health", label: "Gender Health", icon: "âš•ï¸", color: COLORS.rose, bgColor: COLORS.roseBg },
  { key: "surgeries", label: "Surgeries", icon: "ðŸ¥", color: COLORS.orange, bgColor: COLORS.orangeBg },
  { key: "allergies", label: "Allergies", icon: "ðŸ¤§", color: COLORS.warning, bgColor: COLORS.warningBg },
  { key: "body_systems", label: "Body Systems", icon: "ðŸ«€", color: COLORS.danger, bgColor: COLORS.dangerBg },
  { key: "lifestyle", label: "Lifestyle", icon: "ðŸƒ", color: COLORS.success, bgColor: COLORS.successBg },
];

// Format a key like "delivery_type" â†’ "Delivery Type"
function formatKey(key: string): string {
  return key
    .replace(/_/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase());
}

// Format values for display
function formatValue(value: any): string {
  if (value === null || value === undefined || value === "") return "â€”";
  if (Array.isArray(value)) {
    if (value.length === 0) return "None";
    return value.join(", ");
  }
  if (typeof value === "boolean") return value ? "Yes" : "No";
  if (typeof value === "object") return JSON.stringify(value);
  return String(value).replace(/_/g, " ");
}

function addFooter(doc: jsPDF, pageNum: number, totalPages: number) {
  const pageH = doc.internal.pageSize.getHeight();
  const pageW = doc.internal.pageSize.getWidth();
  doc.setDrawColor(...COLORS.border);
  doc.setLineWidth(0.3);
  doc.line(15, pageH - 15, pageW - 15, pageH - 15);
  doc.setFontSize(7);
  doc.setTextColor(...COLORS.muted);
  doc.text("Generated by MedVault â€¢ Confidential Medical Document", 15, pageH - 10);
  doc.text(`Page ${pageNum} of ${totalPages}`, pageW - 15, pageH - 10, { align: "right" });
  doc.text(new Date().toLocaleDateString("en-IN", { day: "2-digit", month: "short", year: "numeric" }), pageW / 2, pageH - 10, { align: "center" });
}

function checkPageBreak(doc: jsPDF, y: number, needed: number = 30): number {
  if (y + needed > doc.internal.pageSize.getHeight() - 20) {
    doc.addPage();
    return 20;
  }
  return y;
}

function addSectionHeader(doc: jsPDF, y: number, step: typeof STEPS[number], pageW: number): number {
  const margin = 15;
  const contentW = pageW - margin * 2;
  y = checkPageBreak(doc, y, 20);

  doc.setFillColor(...step.color);
  doc.roundedRect(margin, y, contentW, 8, 1.5, 1.5, "F");
  doc.setFontSize(10);
  doc.setFont("helvetica", "bold");
  doc.setTextColor(...COLORS.white);
  doc.text(`  ${step.icon}  ${step.label}`, margin + 3, y + 5.8);
  return y + 12;
}

function addKeyValueTable(doc: jsPDF, y: number, data: [string, string][]): number {
  if (data.length === 0) return y;

  autoTable(doc, {
    startY: y,
    margin: { left: 15, right: 15 },
    head: [["Field", "Value"]],
    body: data,
    theme: "plain",
    styles: {
      fontSize: 8,
      cellPadding: { top: 2, bottom: 2, left: 4, right: 4 },
      textColor: COLORS.dark,
      lineColor: COLORS.border,
      lineWidth: 0.2,
    },
    headStyles: {
      fillColor: COLORS.bg,
      textColor: COLORS.muted,
      fontStyle: "bold",
      fontSize: 7,
    },
    columnStyles: {
      0: { cellWidth: 55, fontStyle: "bold", textColor: COLORS.muted },
      1: { cellWidth: "auto" },
    },
  });
  return (doc as any).lastAutoTable.finalY + 6;
}

function addChipList(doc: jsPDF, y: number, label: string, items: string[], color: [number, number, number], bgColor: [number, number, number]): number {
  if (items.length === 0) return y;
  const margin = 15;
  const contentW = doc.internal.pageSize.getWidth() - margin * 2;

  y = checkPageBreak(doc, y, 18);

  doc.setFontSize(8);
  doc.setFont("helvetica", "bold");
  doc.setTextColor(...COLORS.dark);
  doc.text(label, margin + 2, y);
  y += 5;

  // Draw chips
  let x = margin + 2;
  const chipH = 6;
  const chipPadding = 3;
  const maxX = margin + contentW - 2;

  items.forEach((item) => {
    const textW = doc.getTextWidth(item) + chipPadding * 2;
    if (x + textW > maxX) {
      x = margin + 2;
      y += chipH + 2;
      y = checkPageBreak(doc, y, chipH + 4);
    }
    doc.setFillColor(...bgColor);
    doc.roundedRect(x, y - 3.5, textW, chipH, 1.5, 1.5, "F");
    doc.setFontSize(7);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(...color);
    doc.text(item, x + chipPadding, y + 0.5);
    x += textW + 2;
  });

  return y + chipH + 4;
}

// â”€â”€â”€ Section Renderers â”€â”€â”€

function renderBirthHistory(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[0];
  y = addSectionHeader(doc, y, step, pageW);

  const skipKeys = ["notes"];
  const rows: [string, string][] = Object.entries(data)
    .filter(([k]) => !skipKeys.includes(k))
    .map(([k, v]) => [formatKey(k), formatValue(v)]);

  y = addKeyValueTable(doc, y, rows);

  if (data.notes) {
    y = checkPageBreak(doc, y, 15);
    doc.setFontSize(7.5);
    doc.setFont("helvetica", "italic");
    doc.setTextColor(...COLORS.muted);
    const lines = doc.splitTextToSize(`Notes: ${data.notes}`, pageW - 40);
    doc.text(lines, 19, y);
    y += lines.length * 3.5 + 4;
  }
  return y;
}

function renderChildhoodIllnesses(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[1];
  y = addSectionHeader(doc, y, step, pageW);

  if (data.illnesses?.length) {
    y = addChipList(doc, y, "Illnesses", data.illnesses, COLORS.danger, COLORS.dangerBg);
  }
  if (data.other_illnesses) {
    y = checkPageBreak(doc, y, 8);
    doc.setFontSize(7.5);
    doc.setTextColor(...COLORS.dark);
    doc.text(`Other: ${data.other_illnesses}`, 19, y);
    y += 6;
  }
  if (data.vaccines?.length) {
    y = addChipList(doc, y, "Vaccinations Received", data.vaccines, COLORS.success, COLORS.successBg);
  }
  if (data.developmental_notes) {
    y = checkPageBreak(doc, y, 12);
    doc.setFontSize(7.5);
    doc.setFont("helvetica", "italic");
    doc.setTextColor(...COLORS.muted);
    const lines = doc.splitTextToSize(`Developmental Notes: ${data.developmental_notes}`, pageW - 40);
    doc.text(lines, 19, y);
    y += lines.length * 3.5 + 4;
  }
  return y;
}

function renderMedicalConditions(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[2];
  y = addSectionHeader(doc, y, step, pageW);

  const conditions: any[] = data.conditions || [];
  if (conditions.length === 0) {
    doc.setFontSize(8);
    doc.setTextColor(...COLORS.muted);
    doc.text("No conditions recorded", 19, y);
    return y + 8;
  }

  const tableBody = conditions.map((c) => [
    c.name || "â€”",
    (c.status || "â€”").toUpperCase(),
    (c.severity || "â€”").charAt(0).toUpperCase() + (c.severity || "").slice(1),
    c.diagnosed_year || "â€”",
    c.treatment || "â€”",
    c.doctor || "â€”",
  ]);

  autoTable(doc, {
    startY: y,
    margin: { left: 15, right: 15 },
    head: [["Condition", "Status", "Severity", "Year", "Treatment", "Doctor"]],
    body: tableBody,
    theme: "plain",
    styles: {
      fontSize: 7,
      cellPadding: { top: 2, bottom: 2, left: 2, right: 2 },
      textColor: COLORS.dark,
      lineColor: COLORS.border,
      lineWidth: 0.2,
    },
    headStyles: { fillColor: COLORS.bg, textColor: COLORS.muted, fontStyle: "bold", fontSize: 6.5 },
    columnStyles: { 0: { fontStyle: "bold" } },
    didParseCell: (hookData) => {
      if (hookData.section === "body" && hookData.column.index === 1) {
        const status = String(hookData.cell.raw).toLowerCase();
        if (status === "active" || status === "chronic") {
          hookData.cell.styles.textColor = COLORS.danger;
          hookData.cell.styles.fontStyle = "bold";
        } else if (status === "resolved") {
          hookData.cell.styles.textColor = COLORS.success;
        }
      }
    },
  });

  y = (doc as any).lastAutoTable.finalY + 6;
  if (data.notes) {
    doc.setFontSize(7.5);
    doc.setFont("helvetica", "italic");
    doc.setTextColor(...COLORS.muted);
    const lines = doc.splitTextToSize(`Notes: ${data.notes}`, pageW - 40);
    doc.text(lines, 19, y);
    y += lines.length * 3.5 + 4;
  }
  return y;
}

function renderFamilyHistory(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[3];
  y = addSectionHeader(doc, y, step, pageW);

  const condByRelative: Record<string, string[]> = data.conditions_by_relative || {};
  const relatives = Object.entries(condByRelative).filter(([, v]) => v.length > 0);

  if (relatives.length > 0) {
    const tableBody = relatives.map(([rel, conds]) => [rel, conds.join(", ")]);

    autoTable(doc, {
      startY: y,
      margin: { left: 15, right: 15 },
      head: [["Relative", "Conditions"]],
      body: tableBody,
      theme: "plain",
      styles: {
        fontSize: 8,
        cellPadding: { top: 2.5, bottom: 2.5, left: 4, right: 4 },
        textColor: COLORS.dark,
        lineColor: COLORS.border,
        lineWidth: 0.2,
      },
      headStyles: { fillColor: COLORS.purpleBg, textColor: COLORS.purple, fontStyle: "bold", fontSize: 7 },
      columnStyles: { 0: { cellWidth: 50, fontStyle: "bold" } },
    });
    y = (doc as any).lastAutoTable.finalY + 6;
  }

  // Additional fields
  const extraRows: [string, string][] = [];
  if (data.father_age) extraRows.push(["Father's Age", data.father_age]);
  if (data.mother_age) extraRows.push(["Mother's Age", data.mother_age]);
  if (data.consanguinity) extraRows.push(["Consanguinity", formatValue(data.consanguinity)]);
  if (data.cause_of_death) extraRows.push(["Cause of Death", data.cause_of_death]);

  if (extraRows.length > 0) {
    y = addKeyValueTable(doc, y, extraRows);
  }
  return y;
}

function renderGenderHealth(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[4];
  y = addSectionHeader(doc, y, step, pageW);

  const skipKeys = ["notes", "gyn_conditions"];
  const rows: [string, string][] = Object.entries(data)
    .filter(([k]) => !skipKeys.includes(k))
    .map(([k, v]) => [formatKey(k), formatValue(v)]);

  if (rows.length > 0) {
    y = addKeyValueTable(doc, y, rows);
  }

  if (data.gyn_conditions?.length) {
    y = addChipList(doc, y, "Gynecological Conditions", data.gyn_conditions, COLORS.rose, COLORS.roseBg);
  }

  if (data.notes) {
    y = checkPageBreak(doc, y, 12);
    doc.setFontSize(7.5);
    doc.setFont("helvetica", "italic");
    doc.setTextColor(...COLORS.muted);
    const lines = doc.splitTextToSize(`Notes: ${data.notes}`, pageW - 40);
    doc.text(lines, 19, y);
    y += lines.length * 3.5 + 4;
  }
  return y;
}

function renderSurgeries(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[5];
  y = addSectionHeader(doc, y, step, pageW);

  const surgeries: any[] = data.surgeries || [];
  if (surgeries.length > 0) {
    const body = surgeries.map((s) => [
      s.name || "â€”", s.year || "â€”", s.hospital || "â€”", s.reason || "â€”", s.complications || "None",
    ]);
    autoTable(doc, {
      startY: y,
      margin: { left: 15, right: 15 },
      head: [["Surgery", "Year", "Hospital", "Reason", "Complications"]],
      body,
      theme: "plain",
      styles: { fontSize: 7.5, cellPadding: { top: 2, bottom: 2, left: 3, right: 3 }, textColor: COLORS.dark, lineColor: COLORS.border, lineWidth: 0.2 },
      headStyles: { fillColor: COLORS.orangeBg, textColor: COLORS.orange, fontStyle: "bold", fontSize: 7 },
      columnStyles: { 0: { fontStyle: "bold" } },
    });
    y = (doc as any).lastAutoTable.finalY + 6;
  }

  const hosps: any[] = data.hospitalizations || [];
  if (hosps.length > 0) {
    y = checkPageBreak(doc, y, 15);
    doc.setFontSize(8);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(...COLORS.dark);
    doc.text("Hospitalizations", 17, y);
    y += 4;

    const body = hosps.map((h) => [h.reason || "â€”", h.year || "â€”", h.duration || "â€”", h.hospital || "â€”"]);
    autoTable(doc, {
      startY: y,
      margin: { left: 15, right: 15 },
      head: [["Reason", "Year", "Duration", "Hospital"]],
      body,
      theme: "plain",
      styles: { fontSize: 7.5, cellPadding: { top: 2, bottom: 2, left: 3, right: 3 }, textColor: COLORS.dark, lineColor: COLORS.border, lineWidth: 0.2 },
      headStyles: { fillColor: COLORS.bg, textColor: COLORS.muted, fontStyle: "bold", fontSize: 7 },
    });
    y = (doc as any).lastAutoTable.finalY + 6;
  }

  if (surgeries.length === 0 && hosps.length === 0) {
    doc.setFontSize(8);
    doc.setTextColor(...COLORS.muted);
    doc.text("No surgeries or hospitalizations recorded", 19, y);
    y += 8;
  }

  if (data.notes) {
    doc.setFontSize(7.5);
    doc.setFont("helvetica", "italic");
    doc.setTextColor(...COLORS.muted);
    const lines = doc.splitTextToSize(`Notes: ${data.notes}`, pageW - 40);
    doc.text(lines, 19, y);
    y += lines.length * 3.5 + 4;
  }
  return y;
}

function renderAllergies(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[6];
  y = addSectionHeader(doc, y, step, pageW);

  if (data.drug_allergies?.length) {
    y = addChipList(doc, y, "ðŸ’Š Drug Allergies", data.drug_allergies, COLORS.danger, COLORS.dangerBg);
  }
  if (data.other_drug_allergies) {
    doc.setFontSize(7.5);
    doc.setTextColor(...COLORS.dark);
    doc.text(`Other Drug Allergies: ${data.other_drug_allergies}`, 19, y);
    y += 6;
  }
  if (data.food_allergies?.length) {
    y = addChipList(doc, y, "ðŸ½ï¸ Food Allergies", data.food_allergies, COLORS.orange, COLORS.orangeBg);
  }
  if (data.environmental_allergies?.length) {
    y = addChipList(doc, y, "ðŸŒ¿ Environmental Allergies", data.environmental_allergies, COLORS.teal, COLORS.tealBg);
  }

  const extraRows: [string, string][] = [];
  if (data.worst_reaction) extraRows.push(["Worst Reaction", formatValue(data.worst_reaction)]);
  if (data.epipen) extraRows.push(["Carries EpiPen", formatValue(data.epipen)]);
  if (extraRows.length > 0) {
    y = addKeyValueTable(doc, y, extraRows);
  }

  if (data.notes) {
    y = checkPageBreak(doc, y, 12);
    doc.setFontSize(7.5);
    doc.setFont("helvetica", "italic");
    doc.setTextColor(...COLORS.muted);
    const lines = doc.splitTextToSize(`Notes: ${data.notes}`, pageW - 40);
    doc.text(lines, 19, y);
    y += lines.length * 3.5 + 4;
  }
  return y;
}

function renderBodySystems(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[7];
  y = addSectionHeader(doc, y, step, pageW);

  const systemLabels: Record<string, string> = {
    ent: "ðŸ‘‚ ENT & Teeth",
    eyes: "ðŸ‘ï¸ Eyes",
    cardio: "â¤ï¸ Heart & Lungs",
    gi: "ðŸ« Digestive",
    urinary: "ðŸ§ª Urinary",
    skin: "ðŸ§´ Skin & Hair",
    neuro: "ðŸ§  Nervous System",
    musculo: "ðŸ¦´ Bones & Joints",
  };

  const filledSystems = Object.entries(data).filter(
    ([k, v]) => typeof v === "object" && v !== null && Object.keys(v).length > 0
  );

  if (filledSystems.length === 0) {
    doc.setFontSize(8);
    doc.setTextColor(...COLORS.muted);
    doc.text("No body system data recorded", 19, y);
    return y + 8;
  }

  filledSystems.forEach(([sysKey, sysData]) => {
    y = checkPageBreak(doc, y, 20);

    // Sub-header for each body system
    const label = systemLabels[sysKey] || formatKey(sysKey);
    doc.setFillColor(...COLORS.bg);
    doc.roundedRect(17, y - 1, pageW - 34, 6.5, 1, 1, "F");
    doc.setFontSize(8);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(...COLORS.dark);
    doc.text(label, 20, y + 3.5);
    y += 9;

    const skipKeys = ["notes", "teeth_data", "stool_color", "urine_color"];
    const entries = Object.entries(sysData as Record<string, any>)
      .filter(([k, v]) => !skipKeys.includes(k) && v !== "" && v !== null && v !== undefined);

    if (entries.length > 0) {
      const rows: [string, string][] = entries.map(([k, v]) => [formatKey(k), formatValue(v)]);
      y = addKeyValueTable(doc, y, rows);
    }

    if ((sysData as any).notes) {
      y = checkPageBreak(doc, y, 10);
      doc.setFontSize(7);
      doc.setFont("helvetica", "italic");
      doc.setTextColor(...COLORS.muted);
      const lines = doc.splitTextToSize(`Notes: ${(sysData as any).notes}`, pageW - 44);
      doc.text(lines, 21, y);
      y += lines.length * 3.5 + 3;
    }
  });

  return y;
}

function renderLifestyle(doc: jsPDF, y: number, data: Record<string, any>, pageW: number): number {
  const step = STEPS[8];
  y = addSectionHeader(doc, y, step, pageW);

  const skipKeys = ["notes"];
  const rows: [string, string][] = Object.entries(data)
    .filter(([k, v]) => !skipKeys.includes(k) && v !== "" && v !== null && v !== undefined)
    .map(([k, v]) => [formatKey(k), formatValue(v)]);

  if (rows.length > 0) {
    y = addKeyValueTable(doc, y, rows);
  }

  if (data.notes) {
    y = checkPageBreak(doc, y, 12);
    doc.setFontSize(7.5);
    doc.setFont("helvetica", "italic");
    doc.setTextColor(...COLORS.muted);
    const lines = doc.splitTextToSize(`Notes: ${data.notes}`, pageW - 40);
    doc.text(lines, 19, y);
    y += lines.length * 3.5 + 4;
  }
  return y;
}

// â”€â”€â”€ Main Export â”€â”€â”€

export function generateMedicalHistoryPdf(
  history: MedicalHistoryForPdf,
  patientName?: string
) {
  const doc = new jsPDF("p", "mm", "a4");
  const pageW = doc.internal.pageSize.getWidth();
  const margin = 15;
  const contentW = pageW - margin * 2;

  // â”€â”€â”€ Cover Header â”€â”€â”€
  doc.setFillColor(...COLORS.primary);
  doc.rect(0, 0, pageW, 42, "F");

  // Accent stripe
  doc.setFillColor(29, 78, 216);
  doc.rect(0, 42, pageW, 2.5, "F");

  doc.setFontSize(22);
  doc.setFont("helvetica", "bold");
  doc.setTextColor(...COLORS.white);
  doc.text("Complete Medical History", margin, 18);

  doc.setFontSize(11);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(191, 219, 254);
  doc.text(patientName || "Patient Health Record", margin, 27);

  // Stats on right
  const filledCount = STEPS.filter(
    (s) => Object.keys((history as any)[s.key] || {}).length > 0
  ).length;
  const completion = Math.round((filledCount / STEPS.length) * 100);

  doc.setFontSize(8);
  doc.setTextColor(...COLORS.white);
  doc.text(`Completion: ${completion}%`, pageW - margin, 16, { align: "right" });
  doc.text(`${filledCount} of ${STEPS.length} sections filled`, pageW - margin, 22, { align: "right" });
  doc.text(`Generated: ${new Date().toLocaleDateString("en-IN", { day: "2-digit", month: "short", year: "numeric" })}`, pageW - margin, 28, { align: "right" });
  doc.text(`Status: ${history.is_complete ? "âœ… Complete" : "â³ In Progress"}`, pageW - margin, 34, { align: "right" });

  // â”€â”€â”€ Progress bar â”€â”€â”€
  let y = 52;
  doc.setFillColor(...COLORS.border);
  doc.roundedRect(margin, y, contentW, 4, 2, 2, "F");
  doc.setFillColor(...COLORS.primary);
  doc.roundedRect(margin, y, Math.max(contentW * (completion / 100), 4), 4, 2, 2, "F");
  doc.setFontSize(7);
  doc.setTextColor(...COLORS.muted);
  doc.text(`${completion}% Complete`, margin + contentW / 2, y + 10, { align: "center" });
  y += 16;

  // â”€â”€â”€ Table of Contents â”€â”€â”€
  doc.setFontSize(10);
  doc.setFont("helvetica", "bold");
  doc.setTextColor(...COLORS.dark);
  doc.text("Table of Contents", margin, y);
  y += 6;

  STEPS.forEach((step, i) => {
    const filled = Object.keys((history as any)[step.key] || {}).length > 0;
    doc.setFontSize(8);
    doc.setFont("helvetica", "normal");
    const textColor = filled ? COLORS.dark : COLORS.muted;
    doc.setTextColor(textColor[0], textColor[1], textColor[2]);
    doc.text(`${step.icon}  ${i + 1}. ${step.label}`, margin + 4, y);
    const statusColor = filled ? COLORS.success : COLORS.muted;
    doc.setTextColor(statusColor[0], statusColor[1], statusColor[2]);
    doc.text(filled ? "âœ“ Filled" : "â—‹ Empty", pageW - margin, y, { align: "right" });
    y += 5.5;
  });

  y += 6;

  // â”€â”€â”€ Render each section â”€â”€â”€
  const renderers = [
    renderBirthHistory,
    renderChildhoodIllnesses,
    renderMedicalConditions,
    renderFamilyHistory,
    renderGenderHealth,
    renderSurgeries,
    renderAllergies,
    renderBodySystems,
    renderLifestyle,
  ];

  STEPS.forEach((step, i) => {
    const sectionData = (history as any)[step.key] || {};
    if (Object.keys(sectionData).length === 0) return;
    y = renderers[i](doc, y, sectionData, pageW);
    y += 2;
  });

  // â”€â”€â”€ Footers â”€â”€â”€
  const totalPages = doc.getNumberOfPages();
  for (let p = 1; p <= totalPages; p++) {
    doc.setPage(p);
    addFooter(doc, p, totalPages);
  }

  doc.save(`Medical_History_${(patientName || "Patient").replace(/\s+/g, "_")}.pdf`);
}
